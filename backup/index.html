<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#3f51b5">
    <title>Pop - Watch Tracker</title>
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIlBvcCAtIFdhdGNoIFRyYWNrZXIiLAogICJzaG9ydF9uYW1lIjogIlBvcCIsCiAgInN0YXJ0X3VybCI6ICIuIiwKICAiZGlzcGxheSI6ICJzdGFuZGFsb25lIiwKICAiYmFja2dyb3VuZF9jb2xvciI6ICIjM2Y1MWI1IiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiaWNvbi0xOTJ4MTkyLnBuZyIsCiAgICAgICJzaXplcyI6ICIxOTJ4MTkyIiwKICAgICAgInR5cGUiOiAiaW1hZ2UvcG5nIgogICAgfQogIF0KfQ==">
    <style>
    :root {
        --input-focus: #2d8cf0;
        --font-color: #323232;
        --font-color-sub: #666;
        --bg-color: #f5f5f5;
        --main-color: #111111;
        --accent: #3f51b5;
        --card: #ffffff;
        --muted: #9e9e9e;
        --danger: #f44336;
        --success: #4caf50;
        --warning: #ff9800;
        --border-radius: 8px;
        --shadow: 4px 4px var(--main-color);
        --transition: all 0.3s ease;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --bg-color: #121212;
            --card: #1e1e1e;
            --font-color: #f5f5f5;
            --font-color-sub: #9e9e9e;
            --main-color: #798a90;
        }
    }

    [data-theme="dark"] {
        --bg-color: #121212;
        --card: #1e1e1e;
        --font-color: #f5f5f5;
        --font-color-sub: #9e9e9e;
        --main-color: #f5f5f5;
    }

    [data-theme="light"] {
        --bg-color: #f5f5f5;
        --card: #ffffff;
        --font-color: #323232;
        --font-color-sub: #666;
        --main-color: #212121;
    }

    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        font-size: 16px;
        line-height: 1.5;
        color: var(--font-color);
        background-color: var(--bg-color);
        background-color: #212121;
        transition: var(--transition);
        padding: 16px;
    }

    .app-container {
        max-width: 100%;
        min-height: 100vh;
        padding-bottom: 60px; /* Space for FAB */
    }

    /* Header */


.header-card { position: fixed; top:16px; left:16px; right:16px; z-index:1000; }
/* combined header card */
.header-card {
  position: fixed;
  left: 16px;
  right: 16px;
  top: 16px;
  z-index: 1000;
  border-radius: var(--border-radius);
  overflow: hidden;
  box-shadow: var(--shadow);
  border: 2px solid var(--main-color);
  background: var(--card);
}

/* make existing header be the top part */
.header-card .app-header {
  border-radius: 0;
  margin: 0;
  padding-bottom: 8px;
  border: none;
  background: transparent;
}

/* make tabs sit flush as the bottom part of same card */
.header-card .tabs {
  position: relative;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  border-radius: 0 0 var(--border-radius) var(--border-radius);
  margin: 0;
  border: none;
  box-shadow: none;
  background: transparent;
}

/* ensure header-actions sit inside the combined card */
.header-card .header-actions { right: 12px; top: 50%; transform: translateY(-50%); position: absolute; }

/* adjust content offset variable so content doesn't hide behind combined header */
:root { --header-tabs-offset: 120px; } /* tweak if needed based on header height */

/* when wrapped, make inner header/tabs non-fixed and flow inside wrapper */
.header-card .app-header,
.header-card .tabs {
  position: static !important;
  left: auto !important;
  right: auto !important;
  top: auto !important;
  margin: 0 !important;
  border-radius: 0 !important;
  box-shadow: none !important;
  background: transparent !important;
}

/* restore visual borders for inner parts but avoid double outline */
.header-card .app-header { padding: 12px 16px; border-bottom: 1px solid rgba(255,255,255,0.04); }
.header-card .tabs { border-top: 0; display: flex; }

/* ensure header-actions remain positioned inside wrapper */
.header-card .header-actions {
  position: absolute !important;
  top: 25%;
  transform: translateY(-50%);
  right: 12px;
  z-index: 6;
}

/* Give header a unique background */
.header-card {
  background: linear-gradient(135deg, #000000, #000000); /* example blue gradient */
  color: #fff; /* ensure text/icons are readable */
  border-color: #77878d; /* adjust border tone to match */
}

/* override header text inside */
.header-card .app-header h1 {
  color: #90a8f1;
}
.header-card .header-actions .header-fab {
  background: rgba(255,255,255,0.1);
  color: #fff;
  border-color: #fff;
}
.header-card .tabs {
  background: transparent;
}
.header-card .tab {
  color: #fff;
}
.header-card .tab.active {
  background: rgba(0, 0, 0, 0.2);
  border-bottom-color: #3f51b5; /* accent line */
}


/* ensure content offset matches wrapper height (adjust if needed) */
:root { --header-tabs-offset: 120px; }














    .app-header {
        background-color: var(--card);
        background-color: #111111;
        color: var(--font-color);
        color: #abd5e3;
        padding: 16px;
        position: fixed;
        left: 16px;
        right: 16px;
        top: 16px;
        z-index: 1000;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        border-radius: var(--border-radius);
        margin-bottom: 0px;
    }

    .app-header h1 {
        font-size: 1.5rem;
        font-weight: 900;
        display: inline-block;
    }


        /* header search */
    .header-search {
          width: 220px;
          max-width: 40vw;
          padding: 8px 10px;
          border-radius: 999px;
          border: 2px solid var(--main-color);
          background: var(--card);
          color: var(--font-color);
          font-weight: 600;
          box-shadow: var(--shadow);
          outline: none;
          transition: box-shadow .18s ease, transform .12s ease;
        }
.header-search:focus {
          box-shadow: 0 0 0 4px rgba(63,81,181,0.08);
          transform: translateY(-1px);
        }
.header-actions .search-wrapper { display: flex; align-items: center; gap:8px; }
@media (max-width:520px) {
  .header-search { width: 140px; max-width: 36vw; }
}

/* collapsed search style */
.header-search.collapsed {
  width: 0;
  padding: 0;
  border: none;
  box-shadow: none;
  opacity: 0;
  pointer-events: none;
  transition: width 0.2s ease, opacity 0.2s ease;
}

/* expanded state */
.search-wrapper.active .header-search {
  width: 180px;
  padding: 8px 10px;
  border: 2px solid var(--main-color);
  background: var(--card);
  opacity: 1;
  pointer-events: auto;
  box-shadow: var(--shadow);
}

    /* hide/show helper used by JS */
    .hidden { display: none !important; }

    /* header action buttons */
    .header-actions {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        gap: 8px;
        align-items: center;
    }

    /* reuse FAB visuals but reduce size for header */
    .header-fab {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background-color: var(--card);
        color: var(--font-color);
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        padding: 0;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .header-fab:active {
        box-shadow: 0px 0px var(--main-color);
        transform: translate(3px, 3px) translateY(-50%);
    }

    /* prevent global fixed FAB rules from conflicting when in header */
    .app-header .fab {
        position: static;
        right: auto;
        bottom: auto;
        z-index: 101;
    }

    /* Tabs */
    .tabs {
        display: flex;
        background-color: var(--card);
        background-color: #111111;
        position: fixed;
        left: 16px;
        right: 16px;
        z-index: 1000;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        border-radius: var(--border-radius);
        margin: 0;
        margin-bottom: 16px;
        overflow: hidden;
    }

    .tab {
        flex: 1;
        text-align: center;
        padding: 12px;
        cursor: pointer;
        border-bottom: 2px solid transparent;
        font-weight: 600;
        transition: all 0.2s ease;
    }

    .tab.active {
        border-bottom: 2px solid var(--accent);
        background-color: rgba(45, 140, 240, 0.1);
    }

    /* Content */
    .content {
        padding-top: var(--header-tabs-offset);
        margin-top: 0;
    }

    /* Show List */
    .show-list {
        display: flex;
        flex-direction: column;
        gap: 16px;
    }

    /* Show Card */
    .show-card {
        background-color: var(--card);
        border-radius: var(--border-radius);
        padding: 16px;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        transition: var(--transition);
        position: relative;
        overflow: hidden;
    }

    .show-card-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 12px;
    }

    .show-title {
        font-size: 1.2rem;
        font-weight: 900;
    }

    .show-type {
        background-color: var(--accent);
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
    }

    .show-progress {
        margin-bottom: 12px;
    }

    .progress-bar {
        height: 8px;
        background-color: var(--muted);
        border-radius: 4px;
        overflow: hidden;
        border: 1px solid var(--main-color);
    }

    .progress-fill {
        height: 100%;
        background-color: var(--accent);
        border-radius: 4px;
    }

    .progress-text {
        font-size: 0.875rem;
        color: var(--font-color-sub);
        margin-top: 4px;
        font-weight: 600;
    }

    .show-subtitle {
        font-size: 0.875rem;
        color: var(--font-color-sub);
        font-weight: 600;
    }

    /* Show Detail */
    .show-detail {
        background-color: var(--card);
        border-radius: var(--border-radius);
        padding: 16px;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
    }

    .detail-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 16px;
    }

    .detail-actions {
        display: flex;
        gap: 8px;
    }

    .btn {
        background: var(--card);
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        padding: 8px 12px;
        border-radius: var(--border-radius);
        cursor: pointer;
        color: var(--font-color);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        transition: all 0.2s ease;
    }

    .btn:hover {
        background-color: rgba(0,0,0,0.05);
    }

    .btn:active {
        box-shadow: 0px 0px var(--main-color);
        transform: translate(3px, 3px);
    }

    .season-accordion {
        margin-bottom: 18px;
        background: var(--card);
        padding: 12px;
        border-radius: var(--border-radius);
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
    }

    .season-header {
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap: 12px;
        margin-bottom: 12px;
    }

    .season-title {
        font-weight: 900;
        font-size:1rem;
    }

    .season-meta {
        display:flex;
        align-items:center;
        gap:8px;
        color: var(--font-color-sub);
        font-weight: 600;
    }

    .episodes-grid {
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        gap: 10px;
    }

    @media (max-width:720px) {
        .episodes-grid { grid-template-columns: repeat(6, 1fr); }
    }

    @media (max-width:420px) {
        .episodes-grid { grid-template-columns: repeat(6, 1fr); }
    }

    .episode-chip {
        aspect-ratio: 1 / 1;
        display:flex;
        align-items:center;
        justify-content:center;
        background-color: var(--card);
        border-radius: 10px;
        cursor:pointer;
        font-weight:900;
        color: var(--font-color);
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        transition: transform 0.12s ease, box-shadow 0.12s ease;
        user-select:none;
    }

    .episode-chip:active { 
        box-shadow: 0px 0px var(--main-color);
        transform: translate(3px, 3px); 
    }

    .episode-chip:focus { 
        outline: 3px solid rgba(63,81,181,0.16); 
        outline-offset: 2px; 
    }

    .episode-chip.watched {
        background-color: var(--accent);
        color: #fff;
    }

    /* FAB */
    .fab {
        position: fixed;
        bottom: 24px;
        right: 24px;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background-color: var(--card);
        background-color: #abd5e3;
        background-color: #111111;
        color: var(--font-color);
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        cursor: pointer;
        z-index: 1000;
        transition: all 0.2s ease;
    }

    .fab:active {
        box-shadow: 0px 0px var(--main-color);
        transform: translate(3px, 3px);
    }

    /* Modal */
    .modal-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 16px;
    }

    .modal {
        background-color: var(--card);
        border-radius: var(--border-radius);
        width: 100%;
        max-width: 500px;
        max-height: 90vh;
        overflow-y: auto;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
    }

    .modal-header {
        padding: 16px;
        border-bottom: 2px solid var(--main-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .modal-header h2 {
        font-weight: 900;
        color: var(--font-color);
    }

    .modal-body {
        padding: 16px;
    }

    .form-group {
        margin-bottom: 16px;
    }

    label {
        display: block;
        margin-bottom: 8px;
        font-weight: 900;
        color: var(--font-color);
    }

    input, select, textarea {
        width: 100%;
        padding: 12px;
        border: 2px solid var(--main-color);
        border-radius: var(--border-radius);
        background-color: var(--card);
        color: var(--font-color);
        box-shadow: var(--shadow);
        font-weight: 600;
        transition: all 0.2s ease;
    }

    input:focus, select:focus, textarea:focus {
        border: 2px solid var(--input-focus);
    }

    input::placeholder, textarea::placeholder {
        color: var(--font-color-sub);
        opacity: 0.8;
    }

    .modal-footer {
        padding: 16px;
        border-top: 2px solid var(--main-color);
        display: flex;
        justify-content: flex-end;
        gap: 8px;
    }

    .btn-primary {
        background-color: var(--accent);
        color: white;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        padding: 10px 20px;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-weight: 900;
        transition: all 0.2s ease;
    }

    .btn-primary:active {
        box-shadow: 0px 0px var(--main-color);
        transform: translate(3px, 3px);
    }

    .btn-secondary {
        background-color: var(--card);
        color: var(--font-color);
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        padding: 10px 20px;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s ease;
    }

    .btn-secondary:active {
        box-shadow: 0px 0px var(--main-color);
        transform: translate(3px, 3px);
    }

    /* Toast */
    .toast {
        position: fixed;
        bottom: 24px;
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--card);
        color: var(--font-color);
        padding: 12px 24px;
        border-radius: var(--border-radius);
        display: flex;
        align-items: center;
        gap: 16px;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        z-index: 1001;
    }

    .toast-message {
        flex: 1;
        font-weight: 600;
    }

    .toast-action {
        color: var(--accent);
        font-weight: 900;
        cursor: pointer;
    }

    /* Settings */
    .settings-drawer {
        position: fixed;
        top: 0;
        right: -300px;
        width: 300px;
        height: 100vh;
        background-color: var(--card);
        box-shadow: -4px 0 16px rgba(0,0,0,0.15);
        z-index: 1000;
        transition: right 0.3s ease;
        padding: 16px;
        overflow-y: auto;
        border-left: 2px solid var(--main-color);
    }

    .settings-drawer.open {
        right: 0;
    }

    .settings-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 2px solid var(--main-color);
    }

    .settings-header h2 {
        font-weight: 900;
        color: var(--font-color);
    }

    .settings-option {
        margin-bottom: 16px;
    }

    .settings-option label {
        font-weight: 900;
        color: var(--font-color);
        margin-bottom: 8px;
        display: block;
    }



/* Dashboard stat cards */
.dashboard-card {
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04));
  border-radius: 12px;
  padding: 14px;
  border: 2px solid var(--main-color);
  box-shadow: var(--shadow);
  display:flex;
  flex-direction:column;
  gap:8px;
}
.dashboard-card h3 { font-size:1rem; font-weight:900; margin:0; color:var(--font-color); }
.dashboard-value { font-size:1.6rem; font-weight:900; color:var(--accent); }
.dashboard-sub { color:var(--font-color-sub); font-weight:700; font-size:0.9rem; }

/* small table style for breakdown */
.dashboard-table { width:100%; border-collapse: collapse; font-weight:700; color:var(--font-color); }
.dashboard-table td, .dashboard-table th { padding:8px; border-bottom:1px dashed rgba(255,255,255,0.03); text-align:left; }
.dashboard-kpi-row { display:flex; gap:8px; align-items:center; justify-content:space-between; }

/* responsiveness */
@media (max-width:640px) {
  #dashboard-content { grid-template-columns: 1fr; }
}




    /* replace using .hidden for file inputs */
    .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0 0 0 0);
        white-space: nowrap;
        border: 0;
    }

    /* Empty state */
    .empty-state {
        text-align: center;
        padding: 48px 16px;
        color: var(--font-color-sub);
        background-color: var(--card);
        border-radius: var(--border-radius);
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
    }

    .empty-state h2 {
        font-weight: 900;
        margin-bottom: 8px;
    }

    /* Focus styles for accessibility */
    button:focus-visible, input:focus-visible, select:focus-visible, textarea:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
    }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
        * {
            transition: none !important;
        }
    }

    /* Season episode inputs */
    .season-episodes-container {
        margin-bottom: 16px;
    }

    .season-episode-input {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
    }

    .season-episode-input label {
        margin-bottom: 0;
        margin-right: 8px;
        min-width: 100px;
        font-weight: 600;
    }

    /* Back button in detail view */
    .detail-header-with-back {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
    }

    .detail-back-button {
        background: var(--card);
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        color: var(--font-color);
        padding: 8px 10px;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-weight: 600;
        min-width: 56px;
        transition: all 0.2s ease;
    }

    .detail-back-button:active {
        box-shadow: 0px 0px var(--main-color);
        transform: translate(3px, 3px);
    }

    .detail-title-wrap {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 12px;
    }

    .detail-title {
        font-size: 1.35rem;
        font-weight: 900;
        margin-left: 8px;
    }

    .detail-actions {
        display: flex;
        gap: 8px;
        align-items: center;
    }

    .detail-actions .btn {
        background: var(--card);
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        color: var(--font-color);
        padding: 8px 10px;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        transition: all 0.2s ease;
    }

    .detail-actions .btn:active {
        box-shadow: 0px 0px var(--main-color);
        transform: translate(3px, 3px);
    }

    .detail-actions .btn.delete {
        background: var(--card);
        border: 2px solid var(--danger);
        color: var(--danger);
    }

    /* FEATURE: POSTER upload */
    .poster-preview {
        width: 100px;
        height: 150px;
        background-color: var(--muted);
        border-radius: var(--border-radius);
        background-size: cover;
        background-position: center;
        margin-bottom: 12px;
        position: relative;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
    }

    .poster-remove {
        position: absolute;
        top: 4px;
        right: 4px;
        background: var(--danger);
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        font-size: 12px;
        cursor: pointer;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
    }

    .show-card-poster {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-size: cover;
        background-position: center;
        opacity: 0.2;
        z-index: 0;
    }

    .show-card-content {
        position: relative;
        z-index: 1;
    }

    /* FEATURE: SORT control */
    .sort-control {
        display: flex;
        align-items: center;
        padding: 8px 16px;
        background-color: var(--card);
        border-bottom: 2px solid var(--main-color);
        position: sticky;
        top: 104px;
        z-index: 80;
        box-shadow: var(--shadow);
        border-radius: var(--border-radius);
        margin-bottom: 16px;
    }

    .sort-control label {
        margin-right: 8px;
        margin-bottom: 0;
        font-weight: 600;
    }

    .sort-control select {
        width: auto;
        padding: 6px 8px;
    }

    /* FEATURE: Season complete button */
    .season-complete-btn {
        background: var(--accent);
        color: white;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        padding: 6px 10px;
        border-radius: var(--border-radius);
        font-size: 0.85rem;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s ease;
    }

    .season-complete-btn:active {
        box-shadow: 0px 0px var(--main-color);
        transform: translate(3px, 3px);
    }

    /* Small spacing fixes */
    .show-progress { margin-bottom: 12px; }
    .detail-back-button + .detail-title-wrap { margin-left: 0; }

    /* FEATURE: Confirm delete modal */
    .confirm-modal {
        background-color: var(--card);
        border-radius: var(--border-radius);
        padding: 16px;
        max-width: 400px;
        margin: 100px auto;
        text-align: center;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
    }

    .confirm-modal h3 {
        font-weight: 900;
        margin-bottom: 12px;
    }

    .confirm-buttons {
        display: flex;
        justify-content: center;
        gap: 12px;
        margin-top: 16px;
    }

    /* FEATURE: Import/export fallback */
    #settings-drawer .settings-option {
        margin-bottom: 18px;
    }

    /* Make import/export fallback visible and touch-friendly */
    #export-fallback,
    #import-fallback {
        background: var(--card);
        padding: 12px;
        border-radius: var(--border-radius);
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
    }

    /* JSON textarea */
    #export-json,
    #import-json {
        width: 100%;
        min-height: 160px;
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 0.88rem;
        line-height: 1.4;
        padding: 10px;
        border-radius: var(--border-radius);
        box-sizing: border-box;
        resize: vertical;
        color: var(--font-color);
        background: var(--card);
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
    }

    /* Full-width easy-tap buttons inside settings drawer */
    #settings-drawer button,
    #settings-drawer .btn-secondary,
    #settings-drawer .btn-primary {
        width: 100%;
        display: block;
        padding: 10px 40px;
        font-size: 0.95rem;
        border-radius: var(--border-radius);
        box-sizing: border-box;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        transition: all 0.2s ease;
        font-weight: 600;
    }

    #settings-drawer button:active,
    #settings-drawer .btn-secondary:active,
    #settings-drawer .btn-primary:active {
        box-shadow: 0px 0px var(--main-color);
        transform: translate(3px, 3px);
    }

    /* small text link style for import hint */
    #settings-drawer #import-data {
        background: var(--card);
        color: var(--font-color);
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        padding: 10px 12px;
        border-radius: var(--border-radius);
        font-weight: 600;
    }

    /* ===== Add / Edit Modal improvements ===== */
    .modal {
        max-width: 520px;
        padding-bottom: 8px;
    }

    /* modal header and title */
    .modal-header h2 { 
        font-size: 1.25rem; 
        margin: 0; 
        font-weight: 900;
    }

    /* form spacing */
    .modal-body { padding: 16px; }
    .form-group { margin-bottom: 14px; }

    /* inputs visual */
    input, select, textarea {
        background-color: var(--card);
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        color: var(--font-color);
        padding: 10px 12px;
        border-radius: var(--border-radius);
        font-size: 0.95rem;
        font-weight: 600;
    }

    /* nicer placeholder contrast */
    input::placeholder, textarea::placeholder { 
        color: var(--font-color-sub); 
    }

    /* number inputs compact */
    input[type="number"] {
        max-width: 120px;
        text-align: center;
        display: inline-block;
    }

    /* episode inputs inside season editor */
    .season-episode-input {
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 10px;
    }

    .season-episode-input label { 
        min-width: 130px; 
        font-size: 0.95rem; 
        font-weight: 600;
    }

    .season-episode-input input[type="number"] { 
        max-width: 110px; 
    }

    /* Poster preview and buttons layout */
    .poster-preview {
        width: 110px;
        height: 160px;
        border-radius: var(--border-radius);
        background-color: var(--card);
        display: block;
        margin-bottom: 10px;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
    }

    #poster-select-btn,
    #poster-use-url,
    #poster-remove-btn {
        margin: 6px 6px 0 0;
        padding: 8px 10px;
        border-radius: var(--border-radius);
        font-size: 0.9rem;
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        font-weight: 600;
        transition: all 0.2s ease;
    }

    #poster-select-btn:active,
    #poster-use-url:active,
    #poster-remove-btn:active {
        box-shadow: 0px 0px var(--main-color);
        transform: translate(3px, 3px);
    }

    /* arrange poster controls horizontally on wide screens, stacked on small screens */
    .poster-controls { 
        display:flex; 
        gap:8px; 
        flex-wrap:wrap; 
        align-items:center; 
    }

    @media (min-width:420px) {
        .poster-controls { 
            flex-wrap:nowrap; 
            align-items:flex-start; 
        }
    }

    /* modal footer buttons */
    .modal-footer { 
        padding: 12px 16px; 
        gap: 10px; 
        border-top: 2px solid var(--main-color);
    }

    .btn-primary { 
        min-width: 120px; 
        padding: 10px 14px; 
        border-radius: var(--border-radius); 
        font-weight: 900;
    }

    .btn-secondary { 
        min-width: 100px; 
        padding: 10px 12px; 
        border-radius: var(--border-radius); 
        background: var(--card);
        font-weight: 600;
    }

    /* make small helper text consistent */
    .form-group small, .form-hint { 
        display:block; 
        color:var(--font-color-sub); 
        margin-top:6px; 
        font-size:0.85rem; 
        font-weight: 600;
    }

    /* ensure hidden class works for overlays */
    .hidden { display:none !important; }

    /* Accessibility: larger tap targets on mobile */
    @media (max-width:480px) {
        .modal { margin: 12px; max-width: calc(100% - 24px); }
        .header-actions .header-fab { width:44px; height:44px; }
        .fab { width:56px; height:56px; }
    }

    /* FEATURE: Multi-season episode editor */
    .season-editor {
        border: 2px solid var(--main-color);
        box-shadow: var(--shadow);
        border-radius: var(--border-radius);
        padding: 12px;
        margin-bottom: 12px;
    }

    .episode-editor {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 8px;
        margin-bottom: 8px;
        align-items: center;
    }

    .episode-editor label {
        margin-bottom: 0;
        font-weight: 600;
    }

    /* FEATURE: Context menu */
    .context-menu {
        position: fixed;
        background: var(--card);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow);
        z-index: 2000;
        padding: 8px 0;
        min-width: 180px;
        border: 2px solid var(--main-color);
    }

    .context-menu-item {
        padding: 8px 16px;
        cursor: pointer;
        font-weight: 600;
        transition: background-color 0.2s ease;
    }

    .context-menu-item:hover {
        background-color: rgba(0,0,0,0.05);
    }

    /* ===== Toast / Snackbar ===== */
    #toast {
        position: fixed;
        bottom: 24px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--card);
        color: var(--font-color);
        padding: 12px 16px;
        border-radius: var(--border-radius);
        font-size: 0.95rem;
        box-shadow: var(--shadow);
        display: flex;
        align-items: center;
        gap: 12px;
        z-index: 2000;
        animation: fadeInUp 0.25s ease-out;
        border: 2px solid var(--main-color);
    }

    #toast.hidden {
        display: none !important;
    }

    /* Undo button inside toast */
    #toast-action {
        background: transparent;
        border: none;
        color: var(--accent);
        font-weight: 900;
        cursor: pointer;
        padding: 4px 6px;
        border-radius: 4px;
        font-size: 0.9rem;
    }

    #toast-action:hover {
        background: rgba(255,255,255,0.1);
    }

    /* toast message text */
    #toast-message {
        flex: 1;
        font-weight: 600;
    }

    /* animation */
    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translate(-50%, 20px);
        }
        to {
            opacity: 1;
            transform: translate(-50%, 0);
        }
    }

    /* Fix select dropdown visibility */
    select {
        background-color: var(--card);
        color: var(--font-color);
    }

    /* Ensure options render with proper background */
    select option {
        background-color: var(--card);
        color: var(--font-color);
    }
</style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <h1>Pop</h1>

    <!-- moved buttons -->
    <div class="header-actions">

          <div class="search-wrapper" role="search">
  <input id="header-search" class="header-search" type="search" placeholder="Search shows..." aria-label="Search shows">
</div>




        <button class="fab header-fab" id="add-show-fab" aria-label="Add">
            <!-- Plus icon SVG (unchanged) -->
            <svg xmlns="http://www.w3.org/2000/svg" 
             width="24" height="24" 
             viewBox="0 0 24 24" 
             fill="none" stroke="currentColor" 
             stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
        </button>



        <button class="fab header-fab" id="settings-fab" aria-label="Settings">
            <svg xmlns="http://www.w3.org/2000/svg" 
         width="24" height="24" 
         viewBox="0 0 24 24" 
         fill="none" stroke="currentColor" 
         stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 
                 2 0 0 1-2.83 2.83l-.06-.06a1.65 
                 1.65 0 0 0-1.82-.33 1.65 1.65 
                 0 0 0-1 1.51V21a2 2 0 0 
                 1-4 0v-.09a1.65 1.65 0 0 
                 0-1-1.51 1.65 1.65 0 0 
                 0-1.82.33l-.06.06a2 2 0 0 
                 1-2.83-2.83l.06-.06a1.65 
                 1.65 0 0 0 .33-1.82 1.65 
                 1.65 0 0 0-1.51-1H3a2 2 0 
                 0 1 0-4h.09a1.65 1.65 0 0 
                 0 1.51-1 1.65 1.65 0 0 
                 0-.33-1.82l-.06-.06a2 2 0 
                 0 1 2.83-2.83l.06.06a1.65 
                 1.65 0 0 0 1.82.33h.09a1.65 
                 1.65 0 0 0 1-1.51V3a2 2 0 
                 0 1 4 0v.09c0 .66.39 1.26 1 
                 1.51h.09c.61.25 1.31.11 
                 1.82-.33l.06-.06a2 2 0 0 
                 1 2.83 2.83l-.06.06c-.44.51-.58 
                 1.21-.33 1.82v.09c.25.61.85 
                 1 1.51 1H21a2 2 0 0 1 0 4h-.09c-.66 
                 0-1.26.39-1.51 1z"></path>
    </svg>
        </button>
    </div>

        </header>

        <div class="tabs">
            <div class="tab active" data-tab="watching">Watching</div>
            <div class="tab" data-tab="planned">Planned</div>
            <div class="tab" data-tab="finished">Finished</div>
            <div class="tab" data-tab="all">All</div>
        </div>

        <main class="content">
            <div class="show-list" id="show-list">
                <!-- Shows will be rendered here -->
                <div class="empty-state" id="empty-state">
                    <h2>No shows added yet</h2>
                    <p>Get started by adding your first show</p>
                    <button class="btn-primary mt-16" id="add-first-show">Add Show</button>
                </div>
            </div>

            <div class="show-detail hidden" id="show-detail">
                <!-- Show detail will be rendered here -->
            </div>
        </main>

        <div class="fab hidden" id="resume-fab" style="bottom: 1190px;">
            <!-- Resume icon  -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        </div> 

        <button class="fab" id="add-show-fab" style="bottom: 1190px;">
            <!-- Plus icon  -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
        </button>

        <button class="fab" id="settings-fab" style="bottom: 1156px;">
            <!-- Settings icon  -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
        </button>
    </div>

    <!-- Add/Edit Modal -->
    <div class="modal-backdrop hidden" id="add-edit-modal">
        <div class="modal">
            <div class="modal-header">
                <h2 id="modal-title">Add Show</h2>
                <button class="btn" id="close-modal">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <form id="show-form">
                    <input type="hidden" id="show-id">
                    <div class="form-group">
                        <label for="title">Title</label>
                        <input type="text" id="title" required>
                    </div>
                    <div class="form-group">
                        <label for="original-title">Original Title (optional)</label>
                        <input type="text" id="original-title">
                    </div>
                    <div class="form-group">
                        <label for="type">Type</label>
                        <select id="type" required>
                            <option value="tv">TV Show</option>
                            <option value="web">WEB SERIES</option>
                            <option value="movie">Movie</option>
                            <option value="anime">Anime</option>
                        </select>
                    </div>
                    
                    <!-- Poster field inside form -->
<div class="form-group">
  <label>Poster</label>
  <div class="poster-preview" id="poster-preview"></div>

  <!-- Visible-but-offscreen file input that mobile will honour -->
  <input type="file" id="poster-file" accept="image/*" capture="environment" class="visually-hidden">

  <button type="button" class="btn-secondary" id="poster-select-btn">Select Poster</button>
  <button type="button" class="btn-secondary hidden" id="poster-remove-btn">Remove Poster</button>

  <!-- fallback URL field -->
  <div class="mt-16">
    <label for="poster-url">Or paste poster URL</label>
    <input type="url" id="poster-url" placeholder="https://example.com/poster.jpg">
    <button type="button" class="btn-secondary mt-16" id="poster-use-url">Use URL</button>
  </div>
</div>
                    
                    <!-- FEATURE: Multi-season episode editor -->


                    <div class="form-group" id="season-count-group">
  <label for="season-count">Total Seasons</label>
  <input type="number" id="season-count" min="1" value="1">
</div>
                    
                    <div class="form-group hidden" id="season-episodes-group">
                        <label>Episodes per Season</label>
                        <div id="season-episodes-container">
                            <!-- Season episode inputs will be generated here -->
                        </div>
                    </div>
                    <div class="form-group" id="episode-count-group">
                        <label for="episode-count">Episodes per Season (if same)</label>
                        <input type="number" id="episode-count" min="1" value="1">
                    </div>
                    <div class="form-group">
                        <label for="status">Status</label>
                        <select id="status">
                            <option value="planned">Planned</option>
                            <option value="watching">Watching</option>
                            <option value="paused">Paused</option>
                            <option value="finished">Finished</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="tags">Tags (comma separated)</label>
                        <input type="text" id="tags">
                    </div>
                    <div class="form-group">
                        <label for="notes">Notes</label>
                        <textarea id="notes" rows="3"></textarea>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-form">Cancel</button>
                <button class="btn-primary" id="save-show">Save</button>
            </div>
        </div>
    </div>

    <!-- FEATURE: Confirm delete modal -->
    <div class="modal-backdrop hidden" id="confirm-modal">
        <div class="modal confirm-modal">
            <h3 id="confirm-title">Confirm Delete</h3>
            <p id="confirm-message">Are you sure you want to delete this show?</p>
            <div class="confirm-buttons">
                <button class="btn-secondary" id="confirm-cancel">Cancel</button>
                <button class="btn-primary" id="confirm-ok">Delete</button>
            </div>
        </div>
    </div>

    <!-- Settings Drawer -->
    <div class="settings-drawer" id="settings-drawer">
        <div class="settings-header">
            <h2>Settings</h2>
            <button class="btn" id="close-settings">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        
        <div class="settings-option">
            <label for="theme-select">Theme</label>
            <select id="theme-select">
                <option value="system">System</option>
                <option value="light">Light</option>
                <option value="dark">Dark</option>
            </select>
        </div>
        
        <div class="settings-option">
            <label for="sort-by-setting">Default Sort</label>
            <select id="sort-by-setting">
                <option value="recent">Recently Updated</option>
                <option value="alpha">Alphabetical</option>
                <option value="progress">Progress</option>
            </select>
        </div>
        
        <div class="settings-option">
            <button class="btn-primary" id="export-data">Export Data</button>
        </div>
        
        <!-- FEATURE: Import/export fallback -->
        <div class="settings-option hidden" id="export-fallback">
            <p>Export your data as JSON:</p>
            <textarea class="fallback-json" id="export-json" readonly></textarea>
            <button class="btn-secondary" id="copy-json">Copy JSON</button>
        </div>
        
        <div class="settings-option">
            <input type="file" id="import-file" accept=".json,application/json" class="visually-hidden">
            <button id="import-data">Import Data</button>

        </div>

        
        <!-- FEATURE: Import/export fallback -->
        <div class="settings-option hidden" id="import-fallback">
            <p>Paste JSON data to import:</p>
            <textarea class="fallback-json" id="import-json"></textarea>
            <button class="btn-secondary" id="import-from-text">Import from Text</button>
        </div>
        
        <div class="settings-option">
            <button class="btn-secondary" id="clear-data">Clear All Data</button>
        </div>



        <!-- add inside #settings-drawer -->
<div class="settings-option">
  <button class="btn-primary" id="open-dashboard-btn">Open Dashboard</button>
</div>

<!-- Dashboard full-page (hidden) -->
<div id="dashboard-page" class="modal-backdrop hidden" style="padding:24px;">
  <div class="modal" style="max-width:900px; width:100%; overflow:auto;">
    <div class="modal-header">
      <h2>Dashboard</h2>
      <div style="display:flex;gap:8px;align-items:center;">
        <button class="btn" id="close-dashboard">Back</button>
      </div>
    </div>

    <div id="dashboard-content" style="padding:16px; display:grid; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); gap:16px;">
      <!-- stat cards injected here -->
    </div>

    <div style="padding:16px; border-top:2px solid var(--main-color); display:flex; gap:8px; justify-content:flex-end;">
      <button class="btn-secondary" id="dashboard-refresh">Refresh</button>
      <button class="btn-primary" id="dashboard-export">Export Snapshot</button>
    </div>
  </div>
</div>



        
        <div class="settings-option">
            <p>APP Version: <span id="schema-version">2.5.0</span></p>
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast hidden" id="toast">
        <div class="toast-message" id="toast-message"></div>
        <button class="toast-action" id="toast-action">Undo</button>
    </div>

    <!-- FEATURE: Context menu -->
    <div class="context-menu hidden" id="context-menu">
        <div class="context-menu-item" data-action="mark-before">Mark all before this episode</div>
        <div class="context-menu-item" data-action="edit-episode">Edit episode</div>
        <div class="context-menu-item" data-action="copy-info">Copy episode info</div>
    </div>

    <script>
/* Full app script - safe, non-destructive, preserves all IDs/features */



(function() {
  function setHeaderTabsOffset() {
    const header = document.querySelector('.app-header');
    const tabs = document.querySelector('.tabs');
    const content = document.querySelector('.content');
    if (!header || !tabs || !content) return;

    // compute bounding heights including margins
    const headerRect = header.getBoundingClientRect();
    const headerStyle = getComputedStyle(header);
    const headerMarginBottom = parseFloat(headerStyle.marginBottom) || 0;

    // place header at page top spacing (already fixed at top:16px)
    header.style.top = '16px';

    // compute tabs top: header top + header height + 12px gap
    const gap = 12;
    const tabsTop = 16 + headerRect.height + gap; // 16 matches header top offset
    tabs.style.top = tabsTop + 'px';

    // set CSS variable for content padding to avoid overlap
    const totalOffset = tabsTop + tabs.getBoundingClientRect().height + 16; // extra bottom spacing
    document.documentElement.style.setProperty('--header-tabs-offset', totalOffset + 'px');

    // ensure fixed elements full width respects body padding on very small screens
    const left = Math.max(8, parseFloat(getComputedStyle(document.body).paddingLeft) || 16);
    const right = left;
    header.style.left = left + 'px'; header.style.right = right + 'px';
    tabs.style.left = left + 'px'; tabs.style.right = right + 'px';
  }

  window.addEventListener('DOMContentLoaded', setHeaderTabsOffset);
  window.addEventListener('load', setHeaderTabsOffset);
  window.addEventListener('resize', setHeaderTabsOffset);
  // in case dynamic UI changes header size later
  new MutationObserver(setHeaderTabsOffset).observe(document.querySelector('.app-header'), { childList: true, subtree: true, attributes: true });
})();




















// App state
let state = {
  shows: [],
  settings: { theme: 'system', sortBy: 'recent', lastAction: null },
  currentTab: 'watching',
  currentShow: null,
  lastAction: null,
  contextEpisode: null,
  showToDelete: null
};
state.searchQuery = '';



// Utility: safe selector that returns a single element or null.
// If multiple elements have same id, prefer the last one (floating FAB usually last).
function $safe(selector) {
  if (!selector) return null;
  const nodes = document.querySelectorAll(selector);
  if (!nodes || nodes.length === 0) return null;
  return nodes[nodes.length - 1];
}

// Utility: get all nodes (may be empty NodeList)
function $all(selector) {
  return document.querySelectorAll(selector || '');
}

// Utility: addEvent with guard
function on(el, evt, fn) {
  if (!el) return;
  try { el.addEventListener(evt, fn); } catch(e){ console.warn('evt attach failed', evt, e); }
}

// Utility: simple escapeHtml
function escapeHtml(unsafe) {
  if (!unsafe) return '';
  return String(unsafe)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

// Toast helpers
function showToast(msg, withUndo) {
  const toast = $safe('#toast');
  const message = $safe('#toast-message');
  const action = $safe('#toast-action');
  if (!toast || !message) return;
  message.textContent = msg || '';
  if (withUndo && action) action.classList.remove('hidden'); else if (action) action.classList.add('hidden');
  toast.classList.remove('hidden');
  // auto-hide after 4s
  clearTimeout(toast._timer);
  toast._timer = setTimeout(() => { toast.classList.add('hidden'); }, 4000);
}
function hideToast() {
  const toast = $safe('#toast');
  if (toast) toast.classList.add('hidden');
}

// Elements map (use safe selectors)
const elements = {
  showList: $safe('#show-list'),
  emptyState: $safe('#empty-state'),
  showDetail: $safe('#show-detail'),
  resumeFab: $safe('#resume-fab'),
  // duplicate IDs -> get last occurrence to prefer floating control
  addShowFab: $safe('#add-show-fab'),
  settingsFab: $safe('#settings-fab'),
  addEditModal: $safe('#add-edit-modal'),
  settingsDrawer: $safe('#settings-drawer'),
  toast: $safe('#toast'),
  toastMessage: $safe('#toast-message'),
  toastAction: $safe('#toast-action'),
  showForm: $safe('#show-form'),
  modalTitle: $safe('#modal-title'),
  themeSelect: $safe('#theme-select'),
  importFile: $safe('#import-file'),
  seasonCountGroup: $safe('#season-count-group'),
  episodeCountGroup: $safe('#episode-count-group'),
  seasonEpisodesGroup: $safe('#season-episodes-group'),
  seasonEpisodesContainer: $safe('#season-episodes-container'),
  sortControl: $safe('#sort-control'),
  sortBy: $safe('#sort-by'),
  sortBySetting: $safe('#sort-by-setting'),
  posterFile: $safe('#poster-file'),
  posterPreview: $safe('#poster-preview'),
  posterSelectBtn: $safe('#poster-select-btn'),
  posterRemoveBtn: $safe('#poster-remove-btn'),
  posterUrlInput: $safe('#poster-url'),
  posterUseUrlBtn: $safe('#poster-use-url'),
  confirmModal: $safe('#confirm-modal'),
  confirmTitle: $safe('#confirm-title'),
  confirmMessage: $safe('#confirm-message'),
  confirmCancel: $safe('#confirm-cancel'),
  confirmOk: $safe('#confirm-ok'),
  exportFallback: $safe('#export-fallback'),
  exportJson: $safe('#export-json'),
  copyJson: $safe('#copy-json'),
  importFallback: $safe('#import-fallback'),
  importJson: $safe('#import-json'),
  importFromText: $safe('#import-from-text'),
  seasonEditorsContainer: $safe('#season-editors-container'),
  contextMenu: $safe('#context-menu')
};

// PWA placeholder
function setupPWA() {
  let deferredPrompt;
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    // optional: show install UI
  });
  window.addEventListener('appinstalled', () => { deferredPrompt = null; });
}

// Persistence
function saveData() {
  try {
    const dataToSave = {
      meta: {
        appVersion: '1.0.0',
        schemaVersion: 3,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      },
      settings: { ...state.settings, lastAction: state.lastAction },
      shows: state.shows
    };
    localStorage.setItem('watcher:data:v3', JSON.stringify(dataToSave));
  } catch (e) {
    console.error('saveData failed', e);
  }
}
function loadData() {
  try {
    const saved = localStorage.getItem('watcher:data:v3');
    if (!saved) return;
    const parsed = JSON.parse(saved);
    state.shows = parsed.shows || [];
    state.settings = parsed.settings || state.settings;
    if (parsed.settings && parsed.settings.lastAction) state.lastAction = parsed.settings.lastAction;
    // Apply theme safely
    if (typeof setTheme === 'function') setTheme(state.settings.theme);
    if (elements.themeSelect) elements.themeSelect.value = state.settings.theme;
    if (elements.sortBy) elements.sortBy.value = state.settings.sortBy;
    if (elements.sortBySetting) elements.sortBySetting.value = state.settings.sortBy;
    if (state.shows && state.shows.length > 0 && elements.sortControl) elements.sortControl.classList.remove('hidden');
  } catch (e) {
    console.error('Failed to parse saved data', e);
  }
}



// Dashboard logic
function computeDashboardStats() {
  const shows = Array.isArray(state.shows) ? state.shows : [];
  const totals = { tv:0, movie:0, anime:0, web:0, other:0, shows: shows.length, episodesTotal:0, episodesWatched:0 };
  shows.forEach(s => {
    const t = (s.type || '').toLowerCase();
    if (t.includes('tv')) totals.tv++;
    else if (t.includes('movie')) totals.movie++;
    else if (t.includes('anime')) totals.anime++;
    else if (t.includes('web')) totals.web++;
    else totals.other++;

    if (Array.isArray(s.seasons)) {
      s.seasons.forEach(se => {
        if (!Array.isArray(se.episodes)) return;
        totals.episodesTotal += se.episodes.length;
        totals.episodesWatched += se.episodes.filter(e => e.watched).length;
      });
    }
  });
  totals.episodesUnwatched = Math.max(0, totals.episodesTotal - totals.episodesWatched);
  // breakdown by status
  totals.status = shows.reduce((acc,s)=>{
    acc[s.status] = (acc[s.status]||0)+1; return acc;
  },{});
  return totals;
}

function renderDashboard() {
  const el = document.getElementById('dashboard-content');
  if (!el) return;
  el.innerHTML = '';
  const stats = computeDashboardStats();

  // top KPIs
  const kpis = [
    {title:'Total Shows', val: stats.shows, sub: `TV ${stats.tv}  Movies ${stats.movie}  Anime ${stats.anime}`},
    {title:'Total Episodes', val: stats.episodesTotal, sub: `Watched ${stats.episodesWatched}  Unwatched ${stats.episodesUnwatched}`},
    {title:'Watching Now', val: stats.status['watching']||0, sub: 'Shows in Watching'},
    {title:'Planned', val: stats.status['planned']||0, sub: 'Planned to watch'}
  ];

  kpis.forEach(k => {
    const card = document.createElement('div'); card.className = 'dashboard-card';
    card.innerHTML = `<h3>${escapeHtml(k.title)}</h3><div class="dashboard-value">${escapeHtml(String(k.val))}</div><div class="dashboard-sub">${escapeHtml(k.sub)}</div>`;
    el.appendChild(card);
  });

  // breakdown table
  const tableCard = document.createElement('div'); tableCard.className='dashboard-card';
  const rows = `
    <div style="font-weight:900;margin-bottom:8px">Breakdown</div>
    <table class="dashboard-table">
      <tr><th>Type</th><th>Count</th></tr>
      <tr><td>TV Shows</td><td>${stats.tv}</td></tr>
      <tr><td>Movies</td><td>${stats.movie}</td></tr>
      <tr><td>Anime</td><td>${stats.anime}</td></tr>
      <tr><td>Web Series</td><td>${stats.web}</td></tr>
      <tr><td>Other</td><td>${stats.other}</td></tr>
      <tr><td style="font-weight:900">Total Episodes</td><td style="font-weight:900">${stats.episodesTotal}</td></tr>
      <tr><td>Episodes Watched</td><td>${stats.episodesWatched}</td></tr>
      <tr><td>Episodes Unwatched</td><td>${stats.episodesUnwatched}</td></tr>
    </table>
  `;
  tableCard.innerHTML = rows;
  el.appendChild(tableCard);

  // recent activity small card
  const recentCard = document.createElement('div'); recentCard.className='dashboard-card';
  const recent = getRecentActivity(10);
  recentCard.innerHTML = `<h3>Recent Activity</h3><div style="font-weight:700">${recent.length?recent.join('<br>'):'No recent activity'}</div>`;
  el.appendChild(recentCard);
}

function getRecentActivity(limit) {
  const activities = [];
  state.shows.forEach(s=>{
    if (!Array.isArray(s.seasons)) return;
    s.seasons.forEach(se=>{
      se.episodes && se.episodes.forEach(ep=>{
        if (ep.watchedAt) activities.push(`${s.title} S${se.seasonNumber||'?'}E${ep.episodeNumber||'?'}  ${new Date(ep.watchedAt).toLocaleString()}`);
      });
    });
  });
  activities.sort((a,b)=> (new Date(b.split('  ').pop()) - new Date(a.split('  ').pop())));
  return activities.slice(0, limit);
}

// UI wiring
(function dashboardWiring(){
  const openBtn = $safe('#open-dashboard-btn');
  const closeBtn = $safe('#close-dashboard');
  const page = $safe('#dashboard-page');
  const refresh = $safe('#dashboard-refresh');
  const exportBtn = $safe('#dashboard-export');

  if (openBtn && page) on(openBtn, 'click', () => {
    page.classList.remove('hidden');
    renderDashboard();
    // close settings drawer if open
    const sd = $safe('#settings-drawer'); if (sd) sd.classList.remove('open');
  });
  if (closeBtn && page) on(closeBtn, 'click', () => page.classList.add('hidden'));
  if (refresh && page) on(refresh, 'click', () => renderDashboard());
  if (exportBtn && page) on(exportBtn, 'click', () => {
    const snap = computeDashboardStats();
    const blob = new Blob([JSON.stringify(snap,null,2)],{type:'application/json'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'dashboard-snapshot.json'; a.click();
    showToast('Dashboard exported', false);
  });

  // ensure it updates after data changes
  const origSave = window.saveData;
  window.saveData = function() { origSave && origSave(); if (!document.getElementById('dashboard-page')) return; if (!document.getElementById('dashboard-page').classList.contains('hidden')) renderDashboard(); };
})();






// Export / Import
function exportData() {
  if (typeof File === 'undefined' || typeof URL === 'undefined' || typeof URL.createObjectURL === 'undefined') {
    if (elements.exportJson && elements.exportFallback) {
      elements.exportJson.value = JSON.stringify({ settings: state.settings, shows: state.shows }, null, 2);
      elements.exportFallback.classList.remove('hidden');
    }
    return;
  }
  const dataStr = JSON.stringify({ settings: state.settings, shows: state.shows }, null, 2);
  const blob = new Blob([dataStr], { type: 'application/json' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `pop-watch-data-${new Date().toISOString().split('T')[0]}.json`;
  link.click();
  showToast('Data exported', false);
}
function copyJsonToClipboard() {
  if (!elements.exportJson) return;
  elements.exportJson.select();
  document.execCommand('copy');
  showToast('JSON copied to clipboard', false);
}
function importFromText() {
  if (!elements.importJson) return;
  try {
    const importedData = JSON.parse(elements.importJson.value);
    handleImportedData(importedData);
  } catch (e) {
    console.error('Error parsing JSON', e);
    showToast('Error parsing JSON', false);
  }
}
function importData(event) {
  const file = event && event.target && event.target.files ? event.target.files[0] : null;
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const imported = JSON.parse(e.target.result);
      handleImportedData(imported);
      showToast('Data imported', false);
    } catch (err) {
      console.error('Error importing', err);
      showToast('Error importing data', false);
    }
  };
  reader.readAsText(file);
  // reset
  if (event && event.target) event.target.value = '';
}
function handleImportedData(importedData) {
  if (!importedData || !Array.isArray(importedData.shows)) {
    showToast('Invalid import format', false);
    return;
  }
  const merge = confirm('Import and merge data? OK to merge, Cancel to replace');
  if (!merge) {
    if (!confirm('This will replace your current shows. Continue?')) return;
    state.shows = importedData.shows;
    if (importedData.settings) state.settings = importedData.settings;
  } else {
    // merge by id
    const map = new Map(state.shows.map(s => [s.id, s]));
    importedData.shows.forEach(s => {
      if (!map.has(s.id)) map.set(s.id, s); else {
        // simple merge: prefer imported entries for conflicts
        map.set(s.id, { ...map.get(s.id), ...s });
      }
    });
    state.shows = Array.from(map.values());
  }
  saveData();
  render();
}

// Undo
function undoLastAction() {
  if (!state.lastAction) { showToast('Nothing to undo', false); return; }
  const a = state.lastAction;
  switch (a.type) {
    case 'toggleEpisode':
      // restore previous state
      const showIdx = state.shows.findIndex(s => s.id === a.showId);
      if (showIdx === -1) break;
      const season = state.shows[showIdx].seasons.find(s => s.seasonNumber === a.seasonNumber);
      if (!season) break;
      const ep = season.episodes.find(e => e.episodeNumber === a.episodeNumber);
      if (!ep) break;
      ep.watched = a.previousState.watched;
      ep.watchedAt = a.previousState.watchedAt;
      saveData(); renderShowDetail(); renderShowList();
      showToast('Undo completed', false);
      break;
    case 'deleteShow':
      if (a.snapshot) state.shows.push(a.snapshot);
      saveData(); renderShowList(); showToast('Undo completed', false);
      break;
    case 'seasonComplete':
    case 'bulkMark':
      if (a.snapshot) restoreShowFromSnapshot(a.snapshot);
      showToast('Undo completed', false);
      break;
    default:
      showToast('Cannot undo action', false);
  }
  state.lastAction = null;
  saveData();
}

// Snapshot helpers
function createShowSnapshot(show) { return JSON.parse(JSON.stringify(show)); }
function restoreShowFromSnapshot(snapshot) {
  if (!snapshot) return;
  const idx = state.shows.findIndex(s => s.id === snapshot.id);
  if (idx !== -1) state.shows[idx] = snapshot;
  else state.shows.push(snapshot);
  saveData(); render(); if (state.currentShow && state.currentShow.id === snapshot.id) { state.currentShow = snapshot; renderShowDetail(); }
}

// Theme
function setTheme(theme) {
  if (!theme) return;
  const root = document.documentElement;
  if (theme === 'system') {
    root.removeAttribute('data-theme');
  } else {
    root.setAttribute('data-theme', theme);
  }
  state.settings.theme = theme;
  saveData();
}
function applyTheme() {
  setTheme(state.settings.theme || 'system');
}

// Render list and detail
function calculateProgress(show) {
  if (!show || !show.seasons) return 0;
  const total = show.seasons.reduce((t,s) => t + (s.episodes ? s.episodes.length : 0), 0);
  const watched = show.seasons.reduce((t,s) => t + (s.episodes ? s.episodes.filter(e => e.watched).length : 0), 0);
  return total > 0 ? (watched/total)*100 : 0;
}
function getNextUnwatchedEpisode(show) {
  if (!show || !show.seasons) return null;
  for (const season of show.seasons) {
    for (const episode of season.episodes) {
      if (!episode.watched) return { seasonNumber: season.seasonNumber, episodeNumber: episode.episodeNumber, episode };
    }
  }
  return null;
}
function renderShowList() {
  if (!elements.showList) return;
  elements.showList.innerHTML = '';
  const empty = elements.emptyState;
  let filtered = (state.currentTab === 'all') ? state.shows : state.shows.filter(s => s.status === state.currentTab || (state.currentTab === 'watching' && s.status === 'watching'));
  // apply search filter
const q = (state.searchQuery || '').trim().toLowerCase();
if (q) {
  filtered = filtered.filter(s => {
    const inTitle = (s.title || '').toLowerCase().includes(q);
    const inOriginal = (s.originalTitle || s.original_title || '').toLowerCase().includes(q);
    const inTags = Array.isArray(s.tags) ? s.tags.join(' ').toLowerCase().includes(q) : (s.tags || '').toLowerCase().includes(q);
    return inTitle || inOriginal || inTags;
  });
}
  
  // Sort
  const sortBy = state.settings.sortBy || 'recent';
  filtered.sort((a,b) => {
    if (sortBy === 'recent') return new Date(b.updatedAt || 0) - new Date(a.updatedAt || 0);
    if (sortBy === 'alpha') return (a.title||'').localeCompare(b.title||'');
    if (sortBy === 'progress') return calculateProgress(b) - calculateProgress(a);
    return 0;
  });
  if (filtered.length === 0) {
    if (empty) empty.classList.remove('hidden');
    return;
  } else if (empty) empty.classList.add('hidden');

  filtered.forEach(show => {
    const card = document.createElement('div');
    card.className = 'show-card';
    card.tabIndex = 0;
    // poster background
    if (show.posterDataUrl || show.posterUrl) {
      const bg = document.createElement('div');
      bg.className = 'show-card-poster';
      bg.style.backgroundImage = `url(${show.posterDataUrl || show.posterUrl})`;
      card.appendChild(bg);
    }
    const content = document.createElement('div');
    content.className = 'show-card-content';
    const total = show.seasons.reduce((t,s) => t + (s.episodes? s.episodes.length : 0), 0);
    const watched = show.seasons.reduce((t,s) => t + (s.episodes ? s.episodes.filter(e => e.watched).length : 0), 0);
    const progress = total > 0 ? (watched/total)*100 : 0;
    const next = getNextUnwatchedEpisode(show);
    const nextText = next ? (show.type === 'movie' ? 'Movie' : `S${next.seasonNumber}E${next.episodeNumber}`) : '';
    content.innerHTML = `
      <div class="show-card-header">
        <h3 class="show-title">${escapeHtml(show.title)}</h3>
        <span class="show-type">${escapeHtml(show.type || '')}</span>
      </div>
      <div class="show-progress">
        <div class="progress-bar"><div class="progress-fill" style="width: ${progress}%"></div></div>
        <div class="progress-text">${watched}/${total} episodes</div>
      </div>
      <div class="show-subtitle">Next: ${escapeHtml(nextText)}</div>
    `;
    card.appendChild(content);
    on(card, 'click', () => openShowDetail(show));
    elements.showList.appendChild(card);
  });
}

function renderShowDetail() {
  if (!state.currentShow || !elements.showDetail) return;
  openShowDetail(state.currentShow);
}

// Open/close detail
function openShowDetail(show) {
  state.currentShow = show;
  if (elements.showList) elements.showList.classList.add('hidden');
  if (elements.emptyState) elements.emptyState.classList.add('hidden');
  if (elements.showDetail) elements.showDetail.classList.remove('hidden');
  if (elements.resumeFab) elements.resumeFab.classList.remove('hidden');

  // Build detail HTML (improved header)
  const total = show.seasons.reduce((t,s) => t + (s.episodes? s.episodes.length:0), 0);
  const watched = show.seasons.reduce((t,s) => t + (s.episodes? s.episodes.filter(e => e.watched).length:0), 0);
  const progress = total > 0 ? (watched/total)*100 : 0;

  let html = `
    <div class="detail-header-with-back">
      <button class="detail-back-button" id="back-button">Back</button>
      <div class="detail-title-wrap">
        <div class="detail-title">${escapeHtml(show.title)} <span style="font-weight:500; font-size:0.9rem; color:var(--muted); margin-left:8px">(${new Date(show.createdAt||'').getFullYear()||''})</span></div>
      </div>
      <div class="detail-actions">
        <button class="btn" id="edit-show">Edit</button>
        <button class="btn delete" id="delete-show">Delete</button>
      </div>
    </div>

    <div class="show-progress">
      <div class="progress-bar"><div class="progress-fill" style="width: ${progress}%"></div></div>
      <div class="progress-text">${watched}/${total} episodes watched</div>
    </div>
  `;
  show.seasons.forEach(season => {
    const seasonTotal = season.episodes ? season.episodes.length : 0;
    const seasonWatched = season.episodes ? season.episodes.filter(e=>e.watched).length : 0;
    html += `<div class="season-accordion">
      <div class="season-header" data-season="${season.seasonNumber}">
        <div class="season-title">Season ${season.seasonNumber}</div>
        <div><span class="season-progress">${seasonWatched}/${seasonTotal}</span>
        <button class="season-complete-btn" data-season="${season.seasonNumber}">Mark Complete</button></div>
      </div>
      <div class="episodes-grid">`;
    season.episodes.forEach(ep => {
      html += `<div class="episode-chip ${ep.watched ? 'watched' : ''}" data-season="${season.seasonNumber}" data-episode="${ep.episodeNumber}">${ep.episodeNumber}</div>`;
    });
    html += `</div></div>`;
  });
  elements.showDetail.innerHTML = html;

  // Attach listeners inside detail safely
  on($safe('#back-button'), 'click', () => closeShowDetail());
  on($safe('#edit-show'), 'click', () => openAddEditModal(show));
  on($safe('#delete-show'), 'click', () => confirmDeleteShow(show));
  $all('.season-complete-btn').forEach(btn => on(btn, 'click', (e) => { e.stopPropagation(); const n = parseInt(btn.dataset.season); markSeasonComplete(n); }));
  $all('.episode-chip').forEach(chip => on(chip, 'click', (e) => {
    const s = parseInt(chip.dataset.season);
    const ep = parseInt(chip.dataset.episode);
    toggleEpisodeWatched(show, s, ep);
  }));
  $all('.episode-chip').forEach(chip => { chip.tabIndex = 0; chip.setAttribute('role','button'); });
  $all('.season-header').forEach(header => on(header, 'click', (e) => {
    if (e.target && e.target.classList && e.target.classList.contains('season-complete-btn')) return;
    const grid = header.nextElementSibling;
    if (grid) grid.classList.toggle('hidden');
  }));
}

function closeShowDetail() {
  state.currentShow = null;
  if (elements.showDetail) elements.showDetail.classList.add('hidden');
  if (elements.resumeFab) elements.resumeFab.classList.add('hidden');
  if (elements.showList) elements.showList.classList.remove('hidden');
  renderShowList();
}

// Add / Edit modal
function openAddEditModal(show) {
  if (!elements.addEditModal || !elements.showForm) return;
  elements.addEditModal.classList.remove('hidden');

  const form = elements.showForm;

  if (show) {
    elements.modalTitle.textContent = 'Edit Show';

    // basic fields
    form.querySelector('#show-id').value = show.id || '';
    form.querySelector('#title').value = show.title || '';
    form.querySelector('#original-title').value = show.originalTitle || '';
    form.querySelector('#type').value = show.type || 'tv';
    form.querySelector('#status').value = show.status || 'planned';
    form.querySelector('#tags').value = (show.tags || []).join(', ');
    form.querySelector('#notes').value = show.notes || '';

    // poster preview
    if (show.posterDataUrl || show.posterUrl) {
      if (elements.posterPreview) elements.posterPreview.style.backgroundImage = `url(${show.posterDataUrl || show.posterUrl})`;
      if (elements.posterRemoveBtn) elements.posterRemoveBtn.classList.remove('hidden');
    } else {
      if (elements.posterPreview) elements.posterPreview.style.backgroundImage = '';
      if (elements.posterRemoveBtn) elements.posterRemoveBtn.classList.add('hidden');
    }

    // seasons & episodes
    const seasons = Array.isArray(show.seasons) ? show.seasons : [{ seasonNumber: 1, episodes: [{ episodeNumber: 1 }] }];
    const seasonCount = seasons.length;
    const epCounts = seasons.map(s => (s.episodes && s.episodes.length) || 0);

    // set total seasons
    const seasonCountEl = form.querySelector('#season-count');
    if (seasonCountEl) seasonCountEl.value = seasonCount;

    // if all seasons have same episode count, set episode-count; else blank
    const allSame = epCounts.every(c => c === epCounts[0]);
    const episodeCountEl = form.querySelector('#episode-count');
    if (episodeCountEl) episodeCountEl.value = allSame ? (epCounts[0] || '') : '';

    // ensure UI reflects type (hide for movies)
    const typeEl = form.querySelector('#type');
    if (typeEl && typeEl.value === 'movie') {
      if (elements.seasonCountGroup) elements.seasonCountGroup.classList.add('hidden');
      if (elements.episodeCountGroup) elements.episodeCountGroup.classList.add('hidden');
      if (elements.seasonEpisodesGroup) elements.seasonEpisodesGroup.classList.add('hidden');
    } else {
      if (elements.seasonCountGroup) elements.seasonCountGroup.classList.remove('hidden');
      if (elements.episodeCountGroup) elements.episodeCountGroup.classList.remove('hidden');
      // build per-season inputs and populate counts
      updateSeasonEpisodesUI();
      for (let i = 1; i <= seasonCount; i++) {
        const input = document.getElementById(`season-${i}-episodes`);
        if (input) input.value = epCounts[i-1] || (episodeCountEl ? episodeCountEl.value || 1 : 1);
      }
    }

  } else {
    // Add mode
    elements.modalTitle.textContent = 'Add Show';
    form.reset();
    if (elements.posterPreview) elements.posterPreview.style.backgroundImage = '';
    if (elements.posterRemoveBtn) elements.posterRemoveBtn.classList.add('hidden');

    // default season UI
    if (elements.seasonCountGroup) elements.seasonCountGroup.classList.remove('hidden');
    if (elements.episodeCountGroup) elements.episodeCountGroup.classList.remove('hidden');
    updateSeasonEpisodesUI();
  }

  // focus first field for accessibility
  const titleEl = form.querySelector('#title');
  if (titleEl) setTimeout(()=> titleEl.focus(), 120);
}

  // set season UI
  const typeEl = elements.showForm.querySelector('#type');
  if (typeEl && typeEl.value === 'movie') {
    if (elements.seasonCountGroup) elements.seasonCountGroup.classList.add('hidden');
    if (elements.episodeCountGroup) elements.episodeCountGroup.classList.add('hidden');
    if (elements.seasonEpisodesGroup) elements.seasonEpisodesGroup.classList.add('hidden');
  } else {
    if (elements.seasonCountGroup) elements.seasonCountGroup.classList.remove('hidden');
    if (elements.episodeCountGroup) elements.episodeCountGroup.classList.remove('hidden');
    updateSeasonEpisodesUI();
  }


function closeModal() { if (elements.addEditModal) elements.addEditModal.classList.add('hidden'); }

// Save show
function saveShow() {
  if (!elements.showForm) return;
  const id = elements.showForm.querySelector('#show-id').value || (`id_${Date.now()}`);
  const title = elements.showForm.querySelector('#title').value.trim();
  if (!title) { alert('Title required'); return; }
  const type = elements.showForm.querySelector('#type').value;
  const status = elements.showForm.querySelector('#status').value;
  const tags = elements.showForm.querySelector('#tags').value.split(',').map(t=>t.trim()).filter(Boolean);
  const notes = elements.showForm.querySelector('#notes').value;
  // seasons creation
  let seasons = [];
  const seasonCount = parseInt(elements.showForm.querySelector('#season-count') ? elements.showForm.querySelector('#season-count').value : 1) || 1;
  if (type === 'movie') {
    seasons = [{ seasonNumber: 1, episodes: [{ episodeNumber: 1, title: title, watched: false }] }];
  } else {
    const episodeCountSame = parseInt(elements.showForm.querySelector('#episode-count') ? elements.showForm.querySelector('#episode-count').value : 1) || 1;
    for (let i=1;i<=seasonCount;i++){
      const countInput = document.getElementById(`season-${i}-episodes`);
      const count = countInput ? parseInt(countInput.value)||episodeCountSame : episodeCountSame;
      const episodes = [];
      for (let e=1;e<=count;e++) episodes.push({ episodeNumber: e, title: null, watched: false });
      seasons.push({ seasonNumber: i, episodes });
    }
  }
  const existingIndex = state.shows.findIndex(s => s.id === id);
  const now = new Date().toISOString();
  const showObj = {
    id, title, originalTitle: elements.showForm.querySelector('#original-title').value || '',
    type, status, tags, notes,
    seasons,
    posterDataUrl: elements.posterPreview && elements.posterPreview.style && elements.posterPreview.style.backgroundImage ? elements.posterPreview.style.backgroundImage.replace(/^url\(["']?/, '').replace(/["']?\)$/, '') : null,
    updatedAt: now,
    createdAt: existingIndex === -1 ? now : (state.shows[existingIndex] && state.shows[existingIndex].createdAt) || now
  };
  if (existingIndex === -1) state.shows.push(showObj); else state.shows[existingIndex] = showObj;
  saveData();
  closeModal();
  render();
  showToast('Show saved', false);
}

// Delete flow
function confirmDeleteShow(show) {
  if (!elements.confirmModal) return;
  state.showToDelete = show;
  if (elements.confirmTitle) elements.confirmTitle.textContent = 'Confirm Delete';
  if (elements.confirmMessage) elements.confirmMessage.textContent = `Are you sure you want to delete "${show.title}"?`;
  elements.confirmModal.classList.remove('hidden');
}
function confirmDelete() {
  if (!state.showToDelete) return;
  const snapshot = createShowSnapshot(state.showToDelete);
  state.shows = state.shows.filter(s => s.id !== state.showToDelete.id);
  state.lastAction = { type: 'deleteShow', showId: state.showToDelete.id, snapshot };
  saveData();
  if (elements.confirmModal) elements.confirmModal.classList.add('hidden');
  closeShowDetail();
  showToast('Show deleted', true);
  state.showToDelete = null;
}

// Episode toggles and season complete
function toggleEpisodeWatched(show, seasonNumber, episodeNumber) {
  const showIndex = state.shows.findIndex(s => s.id === show.id);
  if (showIndex === -1) return;
  const seasonIndex = state.shows[showIndex].seasons.findIndex(s => s.seasonNumber === seasonNumber);
  if (seasonIndex === -1) return;
  const episodeIndex = state.shows[showIndex].seasons[seasonIndex].episodes.findIndex(ep => ep.episodeNumber === episodeNumber);
  if (episodeIndex === -1) return;
  const prev = { watched: state.shows[showIndex].seasons[seasonIndex].episodes[episodeIndex].watched, watchedAt: state.shows[showIndex].seasons[seasonIndex].episodes[episodeIndex].watchedAt };
  state.lastAction = { type: 'toggleEpisode', showId: show.id, seasonNumber, episodeNumber, previousState: prev };
  const ep = state.shows[showIndex].seasons[seasonIndex].episodes[episodeIndex];
  ep.watched = !ep.watched;
  ep.watchedAt = ep.watched ? new Date().toISOString() : null;
  updateShowStatus(showIndex);
  saveData(); renderShowDetail(); renderShowList();
  showToast(`Episode ${ep.watched ? 'marked as watched' : 'marked as unwatched'}`, true);
}
function updateShowStatus(showIndex) {
  const show = state.shows[showIndex];
  const total = show.seasons.reduce((t,s) => t + (s.episodes? s.episodes.length : 0),0);
  const watched = show.seasons.reduce((t,s) => t + (s.episodes? s.episodes.filter(e=>e.watched).length:0),0);
  if (watched === 0) show.status = 'planned';
  else if (watched === total) show.status = 'finished';
  else show.status = 'watching';
  show.updatedAt = new Date().toISOString();
}
function markSeasonComplete(seasonNum) {
  if (!state.currentShow) return;
  const snapshot = createShowSnapshot(state.currentShow);
  const season = state.currentShow.seasons.find(s => s.seasonNumber === seasonNum);
  if (!season) return;
  let marked = 0;
  const now = new Date().toISOString();
  season.episodes.forEach(ep => { if (!ep.watched) { ep.watched = true; ep.watchedAt = now; marked++; } });
  if (marked > 0) {
    const idx = state.shows.findIndex(s => s.id === state.currentShow.id);
    if (idx !== -1) updateShowStatus(idx);
    state.lastAction = { type: 'seasonComplete', showId: state.currentShow.id, snapshot };
    saveData(); renderShowDetail(); renderShowList();
    showToast(`Marked ${marked} episodes as watched`, true);
  } else showToast('Season already complete', false);
}

// Mark episodes before target
function markEpisodesBefore(targetSeason, targetEpisode) {
  if (!state.currentShow) return;
  const snapshot = createShowSnapshot(state.currentShow);
  let marked = 0; const now = new Date().toISOString();
  for (const season of state.currentShow.seasons) {
    for (const episode of season.episodes) {
      const isBefore = season.seasonNumber < targetSeason || (season.seasonNumber === targetSeason && episode.episodeNumber <= targetEpisode);
      if (isBefore && !episode.watched) { episode.watched = true; episode.watchedAt = now; marked++; }
    }
  }
  if (marked > 0) {
    const idx = state.shows.findIndex(s => s.id === state.currentShow.id);
    if (idx !== -1) updateShowStatus(idx);
    state.lastAction = { type: 'bulkMark', showId: state.currentShow.id, snapshot };
    saveData(); renderShowDetail(); renderShowList();
    showToast(`Marked ${marked} episodes as watched`, true);
  } else showToast('No episodes to mark', false);
}

// Context menu actions
function copyEpisodeInfo(seasonNumber, episodeNumber) {
  if (!state.currentShow) return;
  const show = state.currentShow;
  const season = show.seasons.find(s => s.seasonNumber === seasonNumber);
  if (!season) return;
  const episode = season.episodes.find(ep => ep.episodeNumber === episodeNumber);
  if (!episode) return;
  const text = `${show.title} S${seasonNumber}E${episodeNumber}${episode.title ? ' - ' + episode.title : ''}`;
  navigator.clipboard && navigator.clipboard.writeText ? navigator.clipboard.writeText(text).then(()=>showToast('Episode info copied to clipboard', false)).catch(()=>fallbackCopy(text)) : fallbackCopy(text);
}
function fallbackCopy(text) {
  const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); showToast('Episode info copied', false);
}

// Context menu show
function showContextMenu(episodeChip, e) {
  if (!episodeChip || !elements.contextMenu) return;
  if (!state.currentShow) return;
  const seasonNumber = parseInt(episodeChip.dataset.season);
  const episodeNumber = parseInt(episodeChip.dataset.episode);
  state.contextEpisode = { seasonNumber, episodeNumber, element: episodeChip };
  const clientY = (e && e.clientY) || (e && e.touches && e.touches[0] && e.touches[0].clientY) || 100;
  const clientX = (e && e.clientX) || (e && e.touches && e.touches[0] && e.touches[0].clientX) || 100;
  elements.contextMenu.style.top = clientY + 'px';
  elements.contextMenu.style.left = clientX + 'px';
  elements.contextMenu.classList.remove('hidden');
}
function handleContextMenuAction(e) {
  if (!e || !e.target) return;
  const action = e.target.dataset.action;
  if (!state.contextEpisode) return;
  elements.contextMenu.classList.add('hidden');
  const { seasonNumber, episodeNumber } = state.contextEpisode;
  if (action === 'mark-before') markEpisodesBefore(seasonNumber, episodeNumber);
  else if (action === 'edit-episode') { /* could open editor - placeholder */ showToast('Edit episode (not implemented)', false); }
  else if (action === 'copy-info') copyEpisodeInfo(seasonNumber, episodeNumber);
  state.contextEpisode = null;
}

// Touch & long-press handling
function setupTouchHandling() {
  let pressTimer = null;
  document.addEventListener('touchstart', (e) => {
    const episodeChip = e.target.closest && e.target.closest('.episode-chip');
    if (episodeChip) {
      pressTimer = setTimeout(()=> showContextMenu(episodeChip, e), 500);
    }
  });
  document.addEventListener('touchend', ()=> clearTimeout(pressTimer));
  document.addEventListener('touchmove', ()=> clearTimeout(pressTimer));
  document.addEventListener('contextmenu', (e) => {
    const episodeChip = e.target.closest && e.target.closest('.episode-chip');
    if (episodeChip) { e.preventDefault(); showContextMenu(episodeChip, e); }
  });
}

// Season editor UI
function updateSeasonEpisodesUI() {
  const countEl = $safe('#season-count');
  const episodeCountEl = $safe('#episode-count');
  const seasonCount = parseInt(countEl ? countEl.value : 1) || 1;
  const episodeCount = parseInt(episodeCountEl ? episodeCountEl.value : 1) || 1;
  if (!elements.seasonEpisodesContainer || !elements.seasonEpisodesGroup) return;
  elements.seasonEpisodesContainer.innerHTML = '';
  if (seasonCount > 1) {
    elements.seasonEpisodesGroup.classList.remove('hidden');
    for (let i=1;i<=seasonCount;i++){
      const div = document.createElement('div');
      div.className = 'season-episode-input';
      div.innerHTML = `<label for="season-${i}-episodes">Season ${i} Episodes:</label>
        <input type="number" id="season-${i}-episodes" class="season-episode-count" min="1" value="${episodeCount}">`;
      elements.seasonEpisodesContainer.appendChild(div);
    }
  } else elements.seasonEpisodesGroup.classList.add('hidden');
}

// Poster upload handlers
function handlePosterUpload(e) {
  const file = e && e.target && e.target.files ? e.target.files[0] : null;
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(evt) {
    const dataUrl = evt.target.result;
    if (elements.posterPreview) elements.posterPreview.style.backgroundImage = `url(${dataUrl})`;
    if (elements.posterRemoveBtn) elements.posterRemoveBtn.classList.remove('hidden');
    // Keep in-form preview; saving to show happens on saveShow()
  };
  reader.readAsDataURL(file);
}
function removePoster() {
  if (elements.posterPreview) elements.posterPreview.style.backgroundImage = '';
  if (elements.posterFile) elements.posterFile.value = '';
  if (elements.posterRemoveBtn) elements.posterRemoveBtn.classList.add('hidden');
}
function usePosterUrl() {
  const url = (elements.posterUrlInput && elements.posterUrlInput.value) || '';
  if (!url) { alert('Enter URL'); return; }
  if (elements.posterPreview) elements.posterPreview.style.backgroundImage = `url(${url})`;
  if (elements.posterRemoveBtn) elements.posterRemoveBtn.classList.remove('hidden');
}

// Setup event listeners (safe)
function setupEventListeners() {
  // Tabs
  $all('.tab').forEach(tab => on(tab, 'click', () => {
    $all('.tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    state.currentTab = tab.dataset.tab || 'watching';
    renderShowList();

// header search
const headerSearchEl = document.getElementById('header-search');
if (headerSearchEl) {
  headerSearchEl.addEventListener('input', (e) => {
    state.searchQuery = (e.target.value || '').trim();
    renderShowList();
  });
  headerSearchEl.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      headerSearchEl.value = '';
      state.searchQuery = '';
      renderShowList();
      headerSearchEl.blur();
    }
  });
}

// search expand/collapse
const searchFab = document.getElementById('search-fab');
const searchWrapper = searchFab ? searchFab.parentElement : null;

if (searchFab && searchWrapper) {
  searchFab.addEventListener('click', () => {
    searchWrapper.classList.toggle('active');
    const input = searchWrapper.querySelector('.header-search');
    if (searchWrapper.classList.contains('active')) {
      input.classList.remove('collapsed');
      input.focus();
    } else {
      input.classList.add('collapsed');
      input.value = '';
      state.searchQuery = '';
      renderShowList();
    }
  });
}



  }));

  // FABs
  // FABs (handle duplicate IDs by attaching to all)
document.querySelectorAll('#add-show-fab').forEach(el => {
  el.addEventListener('click', () => openAddEditModal());
});

document.querySelectorAll('#settings-fab').forEach(el => {
  el.addEventListener('click', () => openSettings());
});

if (elements.resumeFab) {
  elements.resumeFab.addEventListener('click', () => resumeShow());
}

  // Modal buttons
  on($safe('#close-modal'), 'click', () => closeModal());
  on($safe('#cancel-form'), 'click', () => closeModal());
  on($safe('#save-show'), 'click', () => saveShow());

  // Settings
  on($safe('#close-settings'), 'click', () => closeSettings());
  on(elements.themeSelect, 'change', () => { setTheme(elements.themeSelect.value); state.settings.theme = elements.themeSelect.value; saveData(); });
  on(elements.sortBySetting, 'change', () => { state.settings.sortBy = elements.sortBySetting.value; if (elements.sortBy) elements.sortBy.value = elements.sortBySetting.value; saveData(); renderShowList(); });

  on($safe('#export-data'), 'click', () => exportData());
  on($safe('#import-data'), 'click', () => {
    if (elements.importFallback && elements.importFallback.classList && !elements.importFallback.classList.contains('hidden')) {
      elements.importFallback.classList.remove('hidden');
    } else if (elements.importFile) {
      elements.importFile.click();
    }
  });
  on(elements.importFile, 'change', importData);
  on($safe('#clear-data'), 'click', () => clearData());

  // Show type/season controls inside form
  on($safe('#type'), 'change', (e) => {
    const v = e && e.target && e.target.value;
    if (v === 'movie') {
      if (elements.seasonCountGroup) elements.seasonCountGroup.classList.add('hidden');
      if (elements.episodeCountGroup) elements.episodeCountGroup.classList.add('hidden');
      if (elements.seasonEpisodesGroup) elements.seasonEpisodesGroup.classList.add('hidden');
    } else {
      if (elements.seasonCountGroup) elements.seasonCountGroup.classList.remove('hidden');
      if (elements.episodeCountGroup) elements.episodeCountGroup.classList.remove('hidden');
      updateSeasonEpisodesUI();
    }
  });
  on($safe('#season-count'), 'change', () => updateSeasonEpisodesUI());
  on($safe('#episode-count'), 'change', () => updateSeasonEpisodesUI());

  // Toast action
  on(elements.toastAction, 'click', () => { undoLastAction(); hideToast(); });

  // Add first show
  on($safe('#add-first-show'), 'click', () => openAddEditModal());

  // Poster upload controls
  on(elements.posterSelectBtn, 'click', () => { if (elements.posterFile) elements.posterFile.click(); });
  on(elements.posterFile, 'change', handlePosterUpload);
  on(elements.posterRemoveBtn, 'click', removePoster);
  on(elements.posterUseUrlBtn, 'click', usePosterUrl);

  // Confirm modal
  on(elements.confirmCancel, 'click', () => elements.confirmModal && elements.confirmModal.classList.add('hidden'));
  on(elements.confirmOk, 'click', confirmDelete);

  // Import/export fallback
  on(elements.copyJson, 'click', copyJsonToClipboard);
  on(elements.importFromText, 'click', importFromText);

  // Context menu
  document.addEventListener('click', (e) => { if (elements.contextMenu && !elements.contextMenu.contains(e.target)) elements.contextMenu.classList.add('hidden'); });
  $all('.context-menu-item').forEach(item => on(item, 'click', handleContextMenuAction));

  // safe service worker registration
if ('serviceWorker' in navigator) {
  const canRegister = (location.protocol === 'https:') || (location.hostname === 'localhost') || (location.hostname === '127.0.0.1');
  if (canRegister) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js').catch(err => console.log('SW failed', err));
    });
  } else {
    console.log('ServiceWorker skipped. Not a secure origin:', location.protocol, location.hostname);
  }
}


  // Touch handling
  setupTouchHandling();

  // Keyboard support
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      if (elements.addEditModal && !elements.addEditModal.classList.contains('hidden')) closeModal();
      else if (elements.settingsDrawer && elements.settingsDrawer.classList.contains('open')) closeSettings();
      else if (state.currentShow) closeShowDetail();
      else if (elements.contextMenu && !elements.contextMenu.classList.contains('hidden')) elements.contextMenu.classList.add('hidden');
    }
  });

  // Back handling
  window.addEventListener('popstate', () => { if (state.currentShow) closeShowDetail(); });
}

// Settings open/close helpers
function openSettings() { if (elements.settingsDrawer) elements.settingsDrawer.classList.add('open'); }
function closeSettings() { if (elements.settingsDrawer) elements.settingsDrawer.classList.remove('open'); }

// Resume stub
function resumeShow() { if (state.currentShow) openShowDetail(state.currentShow); else showToast('No show to resume', false); }

// Clear data
function clearData() {
  if (!confirm('Clear all data?')) return;
  state.shows = []; state.lastAction = null; state.currentShow = null;
  localStorage.removeItem('watcher:data:v3'); render(); showToast('All data cleared', false);
}

// Context menu action handler already defined above (handleContextMenuAction)

// Initialization
function render() { renderShowList(); applyTheme(); }
function init() {
  loadData();
  setupEventListeners();
  render();
  setupPWA();
  // Fallback for missing File API
  if (elements.confirmModal) elements.confirmModal.classList.add('hidden');
if (elements.addEditModal) elements.addEditModal.classList.add('hidden');
if (elements.settingsDrawer) elements.settingsDrawer.classList.remove('open');
if (elements.contextMenu) elements.contextMenu.classList.add('hidden');

  if (typeof File === 'undefined' || typeof URL === 'undefined' || typeof URL.createObjectURL === 'undefined') {
    if (elements.exportFallback) elements.exportFallback.classList.remove('hidden');
    if (elements.importFallback) elements.importFallback.classList.remove('hidden');
  }
}









// runtime wrap header + tabs into .header-card (non-destructive)
(function mergeHeaderCard(){
  const header = document.querySelector('.app-header');
  const tabs = document.querySelector('.tabs');
  if (!header || !tabs) return;
  if (header.parentElement && header.parentElement.classList.contains('header-card')) return;

  const wrapper = document.createElement('div');
  wrapper.className = 'header-card';
  // insert wrapper before header and move header+tabs inside
  header.parentElement.insertBefore(wrapper, header);
  wrapper.appendChild(header);
  wrapper.appendChild(tabs);

  // move header-actions and keep positions correct
  const actions = wrapper.querySelector('.header-actions');
  if (actions) actions.style.position = 'absolute';

  // recompute offsets if function exists
  if (typeof setHeaderTabsOffset === 'function') setHeaderTabsOffset();

  // small safety: ensure .content padding uses computed value
  const computed = wrapper.getBoundingClientRect();
  const tabsRect = tabs.getBoundingClientRect();
  const totalOffset = computed.height + tabsRect.height + 20;
  document.documentElement.style.setProperty('--header-tabs-offset', totalOffset + 'px');
})();













// Start
document.addEventListener('DOMContentLoaded', init);
</script>
